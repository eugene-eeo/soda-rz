#!/usr/bin/env python

import json
import sys
import random
from collections import Counter
from pandas import DataFrame


class Ragezerker:
    __slots__ = ()
    is_ragezerker = True

    def buff(self, members):
        m = random.choice(members)
        if not m.is_ragezerker:
            m.atk += 2

    def copy(self):
        return self


class Actor:
    __slots__ = ('atk', 'p_crit', 'multiplier')
    is_ragezerker = False

    def __init__(self, atk, p_crit, multiplier):
        self.atk = atk
        self.p_crit = p_crit
        self.multiplier = multiplier

    def damage(self):
        if random.random() <= self.p_crit:
            return self.multiplier * self.atk
        return self.atk

    def copy(self):
        return Actor(self.atk, self.p_crit, self.multiplier)


def sim(party):
    ragers = [p for p in party if p.is_ragezerker]
    actors = [p for p in party if not p.is_ragezerker]
    while True:
        for r in ragers:
            r.buff(party)
        yield sum(a.damage() for a in actors)


def run(party, samples, levels, report_every):
    sims = [sim([p.copy() for p in party]) for _ in range(samples)]

    for level in range(1, levels+1):
        seq = [next(s) for s in sims]
        if level % report_every == 0:
            yield level, seq


class SimError(Exception):
    def __init__(self, message):
        Exception.__init__(self)
        self.message = message


def check(data, key, type, message):
    if key not in data or not isinstance(data[key], type):
        raise SimError(
            "Field: {field} (type: {type}) not found.\n"
            "  {field}:\n"
            "  {desc}\n".format(field=key, type=type.__name__, desc=message))


def expect(data, pairs):
    rv = {}
    for key, type, message in pairs:
        check(data, key, type, message)
        rv[key] = data.pop(key)
    if data:
        raise SimError("Config has extraneous variables: %r" % list(data.keys()))
    return rv


def read_config():
    with open('config.json', 'r') as fp:
        data = json.load(fp)

    data = expect(data, [
        ('party',        list, 'array of party members'),
        ('samples',      int,  'number of runs to simulate'),
        ('levels',       int,  'simulate up to the given level'),
        ('report_every', int,  'gather statistics every nth level'),
    ])
    party_member_schema = [
        ('atk',        int,  'initial attack'),
        ('p_crit',     float, '% to crit'),
        ('multiplier', float, 'crit dmg multiplier (100% => 1.0)'),
    ]
    data['party'] = [
        expect(r, party_member_schema) for r in data['party']
    ]
    return data


def run_using(data):
    samples      = int(data['samples'])
    report_every = int(data['report_every'])
    levels       = int(data['levels'])
    party = []
    for member in data['party']:
        party.append(Actor(
            member['atk'],
            member['p_crit'],
            member['multiplier'],
        ))
    party.extend(Ragezerker() for _ in range(5 - len(party)))
    return run(
        party,
        samples,
        levels,
        report_every,
        )


def pdist(seq):
    u = Counter(seq)
    n = sum(u.values())
    Pr = {}
    for x, f in u.items():
        Pr[x] = f / n
    return Pr

def main():
    D = []
    P = []
    L = []

    for level, seq in run_using(read_config()):
        Pr = pdist(seq)
        keys = sorted(Pr)
        D.extend(keys)
        P.extend(Pr[x] for x in keys)
        L.extend(level for _ in range(len(keys)))

    sys.stdout.write(DataFrame({
        'damage': D,
        'probability': P,
        'level': L,
    }).to_json())


if __name__ == '__main__':
    try:
        main()
    except SimError as exc:
        sys.stderr.write(exc.message)
        sys.exit(1)
